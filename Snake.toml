# Battlesnake Configuration File
# All tunable parameters for the MaxN algorithm implementation

# ============================================================================
# Timing & Performance Constants
# ============================================================================
[timing]
# Maximum response time for move endpoint (milliseconds)
response_time_budget_ms = 400
# Network latency buffer (milliseconds)
network_overhead_ms = 50
# How often to recompute optimal move (milliseconds)
polling_interval_ms = 50
# Starting search depth for iterative deepening
initial_depth = 2
# Minimum time remaining to start new iteration (milliseconds)
min_time_remaining_ms = 20
# Safety cap for maximum search depth
max_search_depth = 20

# ============================================================================
# Move Ordering Constants
# ============================================================================
[move_ordering]
# Number of killer moves to track per depth (standard is 2)
killer_moves_per_depth = 2
# Enable PV (Principal Variation) move ordering from previous iteration
enable_pv_ordering = true
# Enable killer move heuristic
enable_killer_heuristic = true

# ============================================================================
# Aspiration Windows Constants
# ============================================================================
[aspiration_windows]
# Enable aspiration windows for 1v1 scenarios (narrows alpha-beta window)
enabled = true
# Initial window size around previous iteration's score (e.g., ±50)
initial_window_size = 50
# Window expansion multiplier when re-searching after fail-high/fail-low
window_expansion_multiplier = 3

# ============================================================================
# Time Estimation Constants
# ============================================================================
# Separate parameters for 1v1 and multiplayer (battle royale) scenarios
# These are automatically selected based on number of alive snakes

[time_estimation]
# Adaptive Time Estimation Blending Factor
# 0.0 = pure empirical (100% observed), 1.0 = pure model (100% formula)
# Reduced from 0.4 to 0.1 based on v3 analysis showing model overestimates complexity
# Analysis showed: depth 6 estimated 345ms but actual 7ms (49x overestimate)
# At 0.1 (10% model, 90% empirical): provides safety buffer without excessive conservatism
model_weight = 0.1

[time_estimation.one_vs_one]
# Base time for iteration estimation in milliseconds
base_iteration_time_ms = 0.01
# Exponential branching factor for time estimation
# Tuned with move ordering: 2.2 achieves depth 7+ with <5% timeouts
# Previous: 2.75 → depth 5.76 (underutilized time budget)
# Previous: 3.25 → depth 4.4 (underutilized time budget)
# Move ordering + aspiration windows enable efficient search
# Dataset: tests/fixtures/optimized_v1/ analysis shows ~80% unused budget at 2.75
branching_factor = 2.2

[time_estimation.multiplayer]
# Base time for iteration estimation in milliseconds
base_iteration_time_ms = 0.01
# Exponential branching factor for time estimation
# Reduced from 1.6 to 1.2 based on v3 analysis showing severe overestimation
# V3 analysis with branching_factor=1.6 showed:
#   - Depth 5-6 average (stopped with 200+ms unused)
#   - Estimator predicted depth 6 = 345ms, actual = 7ms (49x overestimate!)
#   - 100% death by entrapment (need depth 8-10 to see traps forming)
# With branching_factor=1.2 and IDAPOS-filtered 1-2 active snakes:
#   Depth 8: 0.01 * 1.2^(8*2) = 0.01 * 1.2^16 ≈ 79ms ✓
#   Depth 9: 0.01 * 1.2^(9*2) = 0.01 * 1.2^18 ≈ 114ms ✓
#   Depth 10: 0.01 * 1.2^(10*2) = 0.01 * 1.2^20 ≈ 164ms ✓
# Lower branching factor enables deeper search within time budget
branching_factor = 1.2

# ============================================================================
# Strategy Selection Constants
# ============================================================================
[strategy]
# Number of alive snakes to trigger 1v1 strategy
min_snakes_for_1v1 = 2
# Minimum CPU threads to enable parallel execution
min_cpus_for_parallel = 2

# ============================================================================
# Evaluation Score Constants
# ============================================================================
[scores]

# Survival Scores
# Score penalty for dead snake
score_dead_snake = -2147482648  # i32::MIN + 1000
# Massive penalty for not surviving
score_survival_penalty = -1000000
# Weight multiplier for survival component
score_survival_weight = 1000.0

# Component Weights
# Weight for space control score
# Reduced from 30.0 to 25.0 to better balance with food acquisition
# V4 analysis showed wall/space penalties overwhelming food needs at edges
# At 25.0: balanced with health weight for better decision-making
weight_space = 25.0
# Weight for health/food score
# Increased from 50.0 to 75.0 based on v4 food acquisition bug
# V4 game_02 turn 17: adjacent food ignored due to wall/space penalties
# At 75.0: food acquisition dominates when health < 50, allowing edge feeding
weight_health = 75.0
# Weight for territory control score
weight_control = 3.0
# Weight for attack potential score
# Increased from 2.0 to 10.0 to make kill opportunities competitive with space control
# Analysis: attack bonuses of +500 (head-to-head + trap) need 10x multiplier to overcome
# space control differences (space_delta × 20.0). At 10.0, trapped opponent scenarios
# generate +5000 attack score, dominating defensive space gains.
weight_attack = 10.0
# Weight per unit of snake length
weight_length = 100

# Health & Food Constants
# Penalty for zero health
score_zero_health = -100000
# Default distance when no food exists
default_food_distance = 999
# Maximum snake health
health_max = 100.0
# Base penalty for imminent starvation
score_starvation_base = -50000
# Distance threshold for health threat detection
health_threat_distance = 3
# Immediate food bonus - overrides distance penalty for adjacent food
# V4 fix: strongly incentivize grabbing food at distance 1 when safe
# V6 analysis: Game 05 died turn 25 from avoiding safe center food at distance 2
# Extended from distance 1 to 2 to apply bonus for nearby food (not just adjacent)
immediate_food_bonus = 5000
immediate_food_distance = 2

# Space Control Constants
# Extra cells needed beyond snake length
space_safety_margin = 5
# Penalty multiplier per missing cell
space_shortage_penalty = 100

# Territory Control Constants
# Scale factor for territory percentage
territory_scale_factor = 100.0

# Attack Scoring Constants
# Max distance for head-to-head bonus
attack_head_to_head_distance = 3
# Bonus for length advantage near opponent
# Increased from 50 to 200 to strongly incentivize favorable head-to-head collisions
# When bot is longer and opponent is trapped, this bonus should dominate defensive considerations
attack_head_to_head_bonus = 200
# Space margin to detect trapped opponent
attack_trap_margin = 3
# Bonus for trapping opponent
# Increased from 100 to 300 to strongly reward scenarios where opponent has limited escape
# Combined with head-to-head bonus: (200 + 300) × 10.0 = +5000 total attack score
attack_trap_bonus = 300

# Head-to-Head Collision Avoidance
# Strong penalty for positions where we could collide head-to-head with equal/longer opponent
# Reduced from -500000 to -50000 to allow space control to influence decisions when all moves have collision risk
# At -50000: still 25-50x larger than normal score differences but allows meaningful space comparison
head_collision_penalty = -50000

# Wall Proximity Penalty
# Formula: penalty = -wall_penalty_base / (distance + 1) if distance < safe_distance_from_wall, else 0
# Examples (at 500): distance=0 → -500, distance=1 → -250, distance=2 → -167, distance≥3 → 0
# Reduced from 1000 to 500 to allow food acquisition near walls when health demands it
# V4 analysis: wall penalty was preventing adjacent food consumption at board edges
wall_penalty_base = 500              # Base penalty value (divided by distance + 1)
safe_distance_from_wall = 3          # Distance at which wall penalty becomes 0

# Center Bias
# Encourages staying near center to maximize escape routes
# V5 analysis: increased from 10 to 50 to prevent wall-hugging behavior
# Game 03 death: bot stayed along top wall and got trapped after eating corner food
center_bias_multiplier = 50          # Distance multiplier for center bias calculation

# Corner Danger Penalty
# V5 analysis: Game 03 died at corner (10,10) after eating food there
# Exponential penalty as snake approaches corners to prevent entrapment
corner_danger_base = 5000            # Base penalty applied at corner
corner_danger_threshold = 3          # Distance threshold from corner to apply penalty

# Escape Route Evaluation
# V5 fix: Prevent "grab food and die" pattern from Game 03
# V6 analysis: Penalty too aggressive (-3000) caused safe food avoidance in Game 05
# Reduced to -1500 and added health scaling to balance food acquisition vs safety
escape_route_penalty_base = -1500         # Base penalty when escape routes < minimum
escape_route_penalty_health_scale = true  # Scale penalty by health urgency (lower health = lower penalty)
escape_route_min = 2                      # Minimum escape routes required after eating food

# Safe Food Bonus
# V6 analysis: Game 05 avoided food at center (5,5) due to penalty stacking
# Bonus for food at safe central positions to overcome conservative penalties
safe_food_bonus = 2000                    # Bonus for food in safe central area
safe_food_center_threshold = 3            # Manhattan distance from center to qualify as "safe central"

# Length Advantage Bonus
# V5 analysis: Bot stayed small (length 6) while opponents grew (length 19)
# Incentivize growth to match or exceed opponent sizes
length_advantage_bonus = 200         # Bonus per length unit above median opponent length

# Length-Aware Health/Food Constants
# Base snake length for urgency calculation (snakes shorter than this have urgency 1.0x)
health_urgency_base_length = 3.0
# Urgency multiplier per unit of length beyond base (0.1 = 10% increase per length)
health_urgency_length_multiplier = 0.1
# Maximum urgency multiplier (caps exponential growth)
health_urgency_max_multiplier = 2.0
# Minimum urgency multiplier (floor for very short snakes)
health_urgency_min_multiplier = 1.0
# Starvation buffer divisor (buffer = length / divisor, accounts for body navigation)
starvation_buffer_divisor = 3

# Entrapment Detection Constants
# Maximum distance to consider as "nearby" for compactness calculation
entrapment_nearby_threshold = 5
# Compactness ratio threshold for severe entrapment penalty (<0.3 = narrow corridor)
entrapment_severe_threshold = 0.3
# Penalty multiplier for severe entrapment (fraction of reachable space)
entrapment_severe_penalty_multiplier = 0.5
# Compactness ratio threshold for moderate entrapment penalty
entrapment_moderate_threshold = 0.5
# Penalty multiplier for moderate entrapment (fraction of reachable space)
entrapment_moderate_penalty_multiplier = 0.2

# Adversarial Entrapment Constants
# Distance threshold to consider opponent as "nearby threat"
adversarial_entrapment_distance = 3
# Penalty when opponent can reduce our space by this percentage
adversarial_space_reduction_penalty = 10000
# Minimum space reduction percentage to trigger penalty (0.2 = 20%)
adversarial_space_reduction_threshold = 0.2

# Tail-Chasing Detection
# V6 analysis: Games 01 & 03 died from creating tight body loops (self-traps)
# Penalty for body segments clustering near head to prevent self-entrapment
# NUANCED: Only apply when opponents are nearby (indicating active entrapment risk)
tail_chasing_detection_distance = 2     # Manhattan distance to consider body segment "near head"
tail_chasing_penalty_per_segment = 300  # Penalty per nearby body segment
tail_chasing_penalty_exponent = 2.0     # Exponential scaling (nearby_count^exponent)
tail_chasing_opponent_distance = 6      # Only apply penalty if opponent within this distance

# Articulation Point Detection
# Identifies critical positions whose removal would disconnect our reachable space
# High penalty for moves that create articulation points (narrow passageways)
articulation_point_penalty = -2000      # Penalty for positions that are articulation points
articulation_point_enabled = true       # Enable/disable articulation point detection

# ============================================================================
# IDAPOS (Locality Masking) Constants
# ============================================================================
[idapos]
# Multiplier for head-to-head distance check
# Reduced from 2 to 1 for more aggressive locality masking
# At depth 3: considers snakes within distance 3 (was 6)
# This reduces branching factor significantly in battle royale
head_distance_multiplier = 1
# Min snakes in locality to switch to alpha-beta
min_snakes_for_alpha_beta = 2

# ============================================================================
# Move Generation Constants
# ============================================================================
[move_generation]
# Min body length to have a neck segment
snake_min_body_length_for_neck = 1
# Offset from end to exclude tail in collision check
body_tail_offset = 1

# ============================================================================
# Player Index Constants
# ============================================================================
[player_indices]
# Array index for our snake
our_snake_index = 0
# First player index for max player in minimax
player_max_index = 0
# Second player index for min player in minimax
player_min_index = 1

# ============================================================================
# Direction Encoding Constants
# ============================================================================
[direction_encoding]
# Index encoding for Up direction
direction_up_index = 0
# Index encoding for Down direction
direction_down_index = 1
# Index encoding for Left direction
direction_left_index = 2
# Index encoding for Right direction
direction_right_index = 3

# ============================================================================
# Game Rules Constants
# ============================================================================
[game_rules]
# Health restored when eating food
health_on_food = 100
# Health lost per turn
health_loss_per_turn = 1
# Max alive snakes for terminal state
terminal_state_threshold = 1

# ============================================================================
# Debug Configuration
# ============================================================================
[debug]
# Enable debug mode to log game states, moves, and turns to disk
enabled = true
# Path to debug log file (relative to working directory)
log_file_path = "optimized_v7.jsonl"

# ============================================================================
# Performance Profiling Configuration
# ============================================================================
[profiling]
# Enable performance profiling to track where computation time is spent
enabled = false
# Log profiling data to stderr (useful for replay analysis)
log_to_stderr = true
# Track time spent in move generation
track_move_generation = true
# Track time spent in evaluation function (and component breakdown)
track_evaluation = true
# Track time spent in search (alpha-beta, MaxN)
track_search = true
# Track transposition table hit/miss rates
track_transposition_table = true
