# Battlesnake Configuration File
# All tunable parameters for the MaxN algorithm implementation

# ============================================================================
# Timing & Performance Constants
# ============================================================================
[timing]
# Maximum response time for move endpoint (milliseconds)
response_time_budget_ms = 400
# Network latency buffer (milliseconds)
network_overhead_ms = 50
# How often to recompute optimal move (milliseconds)
polling_interval_ms = 50
# Starting search depth for iterative deepening
initial_depth = 2
# Minimum time remaining to start new iteration (milliseconds)
min_time_remaining_ms = 20
# Safety cap for maximum search depth
max_search_depth = 20

# ============================================================================
# Time Estimation Constants
# ============================================================================
# Separate parameters for 1v1 and multiplayer (battle royale) scenarios
# These are automatically selected based on number of alive snakes

[time_estimation.one_vs_one]
# Base time for iteration estimation in milliseconds
base_iteration_time_ms = 0.01
# Exponential branching factor for time estimation
# Value 3.25 = balanced between depth and timeout risk
# Analysis: 1v1 data shows avg 111ms with 240ms unused (68% of budget)
# 50 timeout instances exist but represent <0.3% of all moves
# API behavior: On timeout, continues previous move direction (not catastrophic)
# Trade-off: 3.25 captures most unused budget while minimizing timeout risk
branching_factor = 3.25

[time_estimation.multiplayer]
# Base time for iteration estimation in milliseconds
base_iteration_time_ms = 0.01
# Exponential branching factor for time estimation
# Reduced from 3.5 to 2.25 to enable deeper search in battle royale
# IDAPOS locality masking means only 1-2 snakes are active at shallow depths
# With branching_factor=2.25:
#   Depth 2: 0.01 * 2.25^(2*4) = 0.01 * 2.25^8 ≈ 169ms ✓
#   Depth 3: 0.01 * 2.25^(3*4) = 0.01 * 2.25^12 ≈ 8566ms ✗
# This allows depth 2-3 search reliably
branching_factor = 2.25

# ============================================================================
# Strategy Selection Constants
# ============================================================================
[strategy]
# Number of alive snakes to trigger 1v1 strategy
min_snakes_for_1v1 = 2
# Minimum CPU threads to enable parallel execution
min_cpus_for_parallel = 2

# ============================================================================
# Evaluation Score Constants
# ============================================================================
[scores]

# Survival Scores
# Score penalty for dead snake
score_dead_snake = -2147482648  # i32::MIN + 1000
# Massive penalty for not surviving
score_survival_penalty = -1000000
# Weight multiplier for survival component
score_survival_weight = 1000.0

# Component Weights
# Weight for space control score
# Increased from 10.0 to 20.0 to better avoid getting trapped
weight_space = 20.0
# Weight for health/food score
# Increased from 5.0 to 20.0 to prioritize food when health is low
# Matches space weight so bot balances survival (space) with starvation prevention (health)
weight_health = 20.0
# Weight for territory control score
weight_control = 3.0
# Weight for attack potential score
weight_attack = 2.0
# Weight per unit of snake length
weight_length = 100

# Health & Food Constants
# Penalty for zero health
score_zero_health = -100000
# Default distance when no food exists
default_food_distance = 999
# Maximum snake health
health_max = 100.0
# Base penalty for imminent starvation
score_starvation_base = -50000
# Distance threshold for health threat detection
health_threat_distance = 3

# Space Control Constants
# Extra cells needed beyond snake length
space_safety_margin = 5
# Penalty multiplier per missing cell
space_shortage_penalty = 100

# Territory Control Constants
# Scale factor for territory percentage
territory_scale_factor = 100.0

# Attack Scoring Constants
# Max distance for head-to-head bonus
attack_head_to_head_distance = 3
# Bonus for length advantage near opponent
attack_head_to_head_bonus = 50
# Space margin to detect trapped opponent
attack_trap_margin = 3
# Bonus for trapping opponent
attack_trap_bonus = 100

# Head-to-Head Collision Avoidance
# Strong penalty for positions where we could collide head-to-head with equal/longer opponent
# Reduced from -500000 to -50000 to allow space control to influence decisions when all moves have collision risk
# At -50000: still 25-50x larger than normal score differences but allows meaningful space comparison
head_collision_penalty = -50000

# Wall Proximity Penalty
# Formula: penalty = -wall_penalty_base / (distance + 1) if distance < safe_distance_from_wall, else 0
# Examples (at 1000): distance=0 → -1000, distance=1 → -500, distance=2 → -333, distance≥3 → 0
# Reduced from 10000 to 1000 to prevent wall avoidance from dominating all other strategic considerations
wall_penalty_base = 1000             # Base penalty value (divided by distance + 1)
safe_distance_from_wall = 3          # Distance at which wall penalty becomes 0

# Center Bias
# Encourages staying near center to maximize escape routes
center_bias_multiplier = 10          # Distance multiplier for center bias calculation

# Length-Aware Health/Food Constants
# Base snake length for urgency calculation (snakes shorter than this have urgency 1.0x)
health_urgency_base_length = 3.0
# Urgency multiplier per unit of length beyond base (0.1 = 10% increase per length)
health_urgency_length_multiplier = 0.1
# Maximum urgency multiplier (caps exponential growth)
health_urgency_max_multiplier = 2.0
# Minimum urgency multiplier (floor for very short snakes)
health_urgency_min_multiplier = 1.0
# Starvation buffer divisor (buffer = length / divisor, accounts for body navigation)
starvation_buffer_divisor = 3

# Entrapment Detection Constants
# Maximum distance to consider as "nearby" for compactness calculation
entrapment_nearby_threshold = 5
# Compactness ratio threshold for severe entrapment penalty (<0.3 = narrow corridor)
entrapment_severe_threshold = 0.3
# Penalty multiplier for severe entrapment (fraction of reachable space)
entrapment_severe_penalty_multiplier = 0.5
# Compactness ratio threshold for moderate entrapment penalty
entrapment_moderate_threshold = 0.5
# Penalty multiplier for moderate entrapment (fraction of reachable space)
entrapment_moderate_penalty_multiplier = 0.2

# Adversarial Entrapment Constants
# Distance threshold to consider opponent as "nearby threat"
adversarial_entrapment_distance = 3
# Penalty when opponent can reduce our space by this percentage
adversarial_space_reduction_penalty = 10000
# Minimum space reduction percentage to trigger penalty (0.2 = 20%)
adversarial_space_reduction_threshold = 0.2

# ============================================================================
# IDAPOS (Locality Masking) Constants
# ============================================================================
[idapos]
# Multiplier for head-to-head distance check
# Reduced from 2 to 1 for more aggressive locality masking
# At depth 3: considers snakes within distance 3 (was 6)
# This reduces branching factor significantly in battle royale
head_distance_multiplier = 1
# Min snakes in locality to switch to alpha-beta
min_snakes_for_alpha_beta = 2

# ============================================================================
# Move Generation Constants
# ============================================================================
[move_generation]
# Min body length to have a neck segment
snake_min_body_length_for_neck = 1
# Offset from end to exclude tail in collision check
body_tail_offset = 1

# ============================================================================
# Player Index Constants
# ============================================================================
[player_indices]
# Array index for our snake
our_snake_index = 0
# First player index for max player in minimax
player_max_index = 0
# Second player index for min player in minimax
player_min_index = 1

# ============================================================================
# Direction Encoding Constants
# ============================================================================
[direction_encoding]
# Index encoding for Up direction
direction_up_index = 0
# Index encoding for Down direction
direction_down_index = 1
# Index encoding for Left direction
direction_left_index = 2
# Index encoding for Right direction
direction_right_index = 3

# ============================================================================
# Game Rules Constants
# ============================================================================
[game_rules]
# Health restored when eating food
health_on_food = 100
# Health lost per turn
health_loss_per_turn = 1
# Max alive snakes for terminal state
terminal_state_threshold = 1

# ============================================================================
# Debug Configuration
# ============================================================================
[debug]
# Enable debug mode to log game states, moves, and turns to disk
enabled = true
# Path to debug log file (relative to working directory)
log_file_path = "balanced.jsonl"

# ============================================================================
# Performance Profiling Configuration
# ============================================================================
[profiling]
# Enable performance profiling to track where computation time is spent
enabled = false
# Log profiling data to stderr (useful for replay analysis)
log_to_stderr = true
# Track time spent in move generation
track_move_generation = true
# Track time spent in evaluation function (and component breakdown)
track_evaluation = true
# Track time spent in search (alpha-beta, MaxN)
track_search = true
# Track transposition table hit/miss rates
track_transposition_table = true
